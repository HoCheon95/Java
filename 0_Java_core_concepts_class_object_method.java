※ OOP란?
 - Object-Oriented-Programming
 - 객체지향프로그래밍
※ 특징
 1. 캡슐화
 2. 상속
 3. 다형성
 4. 추상화


1) 클래스(Class)
 - 객체를 생성하기 위한 정의
 - 설계도 / 틀
 - "어떤 데이터를 가지고(필드), 어떤 행동을 할지(메서드)"를 한 덩어이로 정의한 것

class Car{
	String color;	// 필드(변수)
	void run();		// 메서드
}

클래스 소속 멤버변수(속성) 기본값)
 - 멤버변수만 선언하고 명시적인 코드로 초기화를 하지 않으면 기본값으로 초기화가 된다.
   - int 타입 속성은 0 초기화
   - boolean 타입 속성은 false 초기화
   - double 타입 속성은 0.0  초기화
   - String 타입 속성은 null 초기화

/*======================================================================*/

2) 객체(Object) = 인스턴스(Instance)
 - 클래스로 실제로 만들어진 "실체"
 - 클래스가 설계도라면, 객체는 그 설계도로 찍어낸 실제 제품

Car c1 = new Car(); // 객체 생성
Car c2 = new Car(); // 또 다른 객체 생성

new Car()	// 힙(heap)에 객체 생성
Car c1		// Car 타입의 참조변수 선언
=			// 생성된 객체의 주소를 저장

/*======================================================================*/

3)변수(Variable)
 (1) 지역 변수(Local Variable)
  - 메서드 안에서만 쓰고, 메서드 끝나면 사라짐
void f(){
	int x = 10;	// 지역 변수
}

 (2) 필드(Field) = 멤버 변수(Memver Variable)
  - 클래스 안에 선언되는 변수
  - 객체가 가지는 '속성'
class Car{
	int speed; // 필드(멤버변수)
}
 
 (3) 정적 변수(static 변수, 클래스 변수)
  - 객체마다 따로 있는 게 아니라, '클래스에 1개만 공유'
class Counter{
	static int count = 0; // 정적변수 

	Counter(){
		count++; // 객체가 생성될 때마다 증가
	}

 (4) 레퍼런스(reference)
  - 객체를 가리키는 주소값(또는 그 변수)
--------------------
표현            의미	 
--------------------
참조 변수        객체의 주소를 저장하는 변수
레퍼런스 변수      참조 변수와 동일 
레퍼런스         객체를 가리키는 주소값(또는 그 변수)
"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"
ex)
String s = "hello";
s : 참조변수 / 레퍼런스 변수
"hello" : 객체
s 안에는 객체 주소(레퍼런스)가 들어 있음
"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"

 (5) private(접근제어자)
  - 같은 클래스 내부에서만 접근 가능 하도록 제한하는 접근 제어자

}
public class Main {
    public static void main(String[] args) {

        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

        System.out.println(Counter.count); // 3
    }
}

/*======================================================================*/

4) 메서드(Method)
 - 클래스 안에 정의된 '기능(행동)'
 - 입력(매개변수)을 받아서 처리하고, 결과(리턴)이 있거나 없기도 하다.

int add(int a, int b){
	return a + b;
}

/*======================================================================*/

5) 매개변수(Parameter) vs 전달인자(Argument)
 - 매개변수 : 메서드 '정의할 때' 적는 변수
 - 전달인자 : 메서드 '호출할 때' 넣는 실제 값

void printSum(int a, int b){ // a, b = 매개변수
	System.out.println(a + b);
}

printSum(3, 5); // 전달인자

/*======================================================================*/

6) static(정적) 메서드 vs 인스턴스 메서드
 (1) 정적 메서드(static method)
  - 객체 없이 '클래스명으로 바로 호출' 가능
  - 클래스에 고정된 기능(공유 가능)
  - 객체 상태(필드) 없이도 되는 계산/유틸에 주로 씀
class Cal{
	static int add(int a, int b){
		return a + b;
	}
}

 (2) 인스턴스 메서드(일반 메서드)
  - 객체를 만들어서 '객체로 호출'
  - 객체의 상태(필드)를 다루는 기능에 적합
class Car{
	int speed;
	void accel(){
		speed++;
	}
}

Car c = new Car();
c.accel();

Calc.add(1, 2);

/*======================================================================*/

7) 생성자(Constructor)
 - 객체를 만들 때 딱 1번 실행되는 '초기화 전용 메서드 비슷한 것'
 - 특징
   - 이름이 '클래스명과 같음'
   - 'new 클래스명();' 에 의해서 호출
   - '리턴타입'이 없음
   - 생성자도 '메서드의 일종'이기 때문에 '오버로딩이 가능'하다.
   - '기본 생성자'는 '매개변수가 없는 생성자'를 말한다. 
     생성자가 오버로딩이 안된 경우에는 자바 컴파일러는 묵시적인 기본생성자를 제공한다
   - 생성자가 오버로딩이 되면 자바 컴팡일러는 더 이상 묵시적인 기본생성자를 제공하지 않는다.
 - 같은 클래스에서 다른 생성자 호출 법
   - this();

/*======================================================================*/

5주차 요점정리.pdf No.1
8) this
 - 좌측 멤버변수와 우측 매개변수명이 같을 때는 멤머변수 앞에 this.을 붙여야 저장된다.
 - this는 내 자신 인스턴스 가리키는 참조 변수이다.

 this.name = name;


/*======================================================================*/

9) 정적메서드
 - static 이란 예약어 사용
 - 인스턴스 차원이 아닌 클래스 차원에서 사용하도로고 설계
   - 인스턴스(객체) 생성 없이 클래스명으로 호출 가능
 - 'this 래퍼런스를 사용 불가' 65줄 참고
 - '인스턴스 변수 사용 불가'

/*======================================================================*/

10) 상속
 - 상속이란 자식이 부모가 가지고 있는 재산이나 권력을 물려받는다는 의미이다.
 - '생성자는 상속이 안된다'
 - 특정(자식) 클래스는 다른(부모) 클래스가 가지고 있는 모든 멤버변수나 멤버함수를 사용할 수 있다.
 class 자식_클래스 extends 부모_클래스{

 }

/*======================================================================*/

11) 접근 지정자(제어자)
| 접근 지정자	| 같은 클래스	| 같은 패키지	| 자식 클래스(다른 패키지)	| 전체	|
| --------- | ------	| ------	| --------------	| --	|
| public    | ⭕			| ⭕			| ⭕					| ⭕		|
| protected | ⭕			| ⭕			| ⭕					| ❌		|
| default   | ⭕			| ⭕			| ❌					| ❌		|
| private   | ⭕			| ❌			| ❌					| ❌		|

public -> protected -> default -> private
[점점 좁아짐]


기호		의미					자바 접근 지정자
+		public				public
#		protected			protected
~		default (package)	접근지정자 없음
-		private				private


/*======================================================================*/

11) 오버로딩 과 오버라이딩 차이점
 1. 오버러딩 이란?
   상속과 관련이 없다. 동일한 같은 클래스내에서 같은 이름의 메서드명을 중복해서 여러번 정의하는 것을 말한다.
   - 매개변수의 '개수'를 다르게 한다.
   - 매개변수의 '타입'을 다르게 한다.
   - 매개변수의 '순서'를 다르게 한다.
  
  2. 오버라이딩?
   - 오버라이딩을 하기 위해서 사전에 반드시 '상속관계'를 만들어야한다.
   - 상속관계에서 부모의 메서드명, 메서드 리턴타입, 매개변수 타입과 개수 모두 동일한 '원형'을 자손에서 상속받은 
     상태에서'부모클래스로 부터 상속받은 메서드 내용을 자식 클래스에 맞게 변경하는 것을 오버라이딩 이라 한다.'
   - '주의할 것은 생성자는 상속되지 않는다'. 그러므로 생성자 오버로딩 문법은 존재하지만 오버라이딩 문법은 없다.

   - '생성자가 오버로딩되면 자바는 기본생성자를 묵시적으로 제공하지 않는다.'
   - '생성자가 오버로딩 될 때 자식클래스에서 기본생성자를 호출하고자 할 때 문제가 발생'한다.
   - '부모클래스에서 생성자가 오버로딩 되면 상속에서의 생성자 호출문제가 발생 명시적인 기본생성자를 정의하는 것이 좋다.'

   - 생성자는 상속되지 않는다.
   - 자식클래스에서 new 클래스명();에 의해서 생성자를 호출하면 자바는 먼저 부모클래스 기본생성자를 먼저
     호출하도록 설계 되어져 있다.
  
  3. 상속관계에서 자손에서 부모의 메서드를 호출할 때는 super.메서드();를 사용 한다.
/*======================================================================*/

12) 업캐스팅, 다운캐스팅
 (1) 업캐스팅
  - 업캐스팅을 하려면 사전에 상속 관계를 만들어야 한다.
  - 업캐스팅이란 자손타입이 부모타입으로 올라가는 현상을 말한다. 업캐스팅은 암묵적인 자동형 변환을 해준다.

/*======================================================================*/
클래스는 개념을 만들기 위해,
메서드는 행동을 분리하기 위해,
생성자는 객체를 안전하게 만들기 위해,
자식 클래스는 공통을 재사용하고 확장하기 위해 사용한다.


 우클릭 Source
Generate Getters and Setter Methods

Select All
 ㄴ 전체 getter, setter 선택
 Deselect All
  ㄴ 전체 해제

Select Getters
 ㄴ Gettser 선택
Select Setters
 ㄴ Setter 선택

 구글에 롬복 다운로드
 파일 다운로드 후 .jar -> java Program 붙여넣기
D:\20251201_java\Program

주소창에 cmd 입력
java -jar lombok.jar
ㄴ path 안잡혀서 그럼
ㄴ 어디서든 java 명령어 실행하고 싶으면 아래 단계 실행

java jdk 설치 경로 복사
D:\20251201_java\Program\sts-4.32.2\sts-4.32.2.RELEASE\plugins\org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_21.0.9.v20251105-0741\jre\bin

내 pc 
고급시스템 설정
환경변수
시스템변수 -> path 편집
새로만들기
경로 붙여넣기
확인

D:\20251201_java\Program cmd 재부팅

Specify location
SpringToolSuite4.exe 파일 선택

인스톨
퀵인스톨

경로안에 lombok.jar 설치됐는지 체크 후 

sts실행





