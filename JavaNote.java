[접근 제어자] [기타 제어자] [반환 타입] [메서드명] (매개변수 목록)
1. 접근 제어자
 · 메서드에 접근할 수 있는 범위를 결정
 · 4개 중 하나만 선택
| 접근 지정자 | 같은 클래스| 같은 패키지 | 자식 클래스(다른 패키지)	| 전체		|
| --------- | ------      | ------     | --------------		    | --		|
| public    | ⭕          | ⭕        | ⭕					    | ⭕		|
| protected	| ⭕          | ⭕        | ⭕					    | ❌		|
| default   | ⭕          | ⭕        | ❌				    	| ❌		|
| private   | ⭕          | ❌        | ❌				    	| ❌		|

기호		의미					자바 접근 지정자
+		public				public
#		protected			protected
~		default (package)	접근지정자 없음
-		private				private

2. 기타 제어자
 · static : 객체 없이 호출 가능
 · final : 오버라이딩 불가
 · abstract : 추상 클래스 / 구현 없음
 · synchronized : 동기화
 · native : C/C++ 연동
 · strictfp : 실수 연산 표준화
 · 0개 이상 가능(여러 개 가능)

3. 반환 타입
 · void : return 없음 / void 사용 안할시 return 있음
 · 기본형 (int, double, boolean, char, byte, float, short, long)
 · 참조형 (String, 클래스형, 배열형, 인터페이스 형)

4. 메서드명
 · 메서드를 호출할 떄 사용하는 이름

5. 매개변수 목록
 · 메서드 호출 시 전달받는 값

'ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ'

1) 클래스(Class)
 - 정의 : 객체를 정의해 놓은 것
 - 용도 : 객체를 생성하는데 사용
 - '어떤 데이터를 가지고(필드), 어떤 행동을 할지(메서드)'를 한 덩어리로 정의한 것

2) 객체(Object)
 - 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻함
	Car c1 = new Car(); // 객체 생성
	Car c2 = new Car(); // 또 다른 객체 생성

	new Car() // 힙(heap)에 객체 생성
	Car c1    // Car 타입의 참조변수 선언
	=		   // 생성된 객체의 주소를 저장

3) 인스턴스(Instance)(객체)
 - 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

4) 변수(Variable)
 (1) 지역 변수(Local Variable)
  - '메서드', '생성자', 또는 '블록({})' '안에서 선언'되어 그 '블록 안에서만 사용 가능한 변수'
  - '초기값' 설정 해줘야됨

 (2) 필드(Field) = 멤버 변수(Member Variable)
  - 클래스 안에 선언되는 변수
  - 객체가 가지는 '속성'

 (3) 정적 변수(static 변수, 클래스 변수)
  - static 키워드로 선언
  - 모든 객체가 하나의 값을 공유
  - 클래스에서만 선언 가능
  - 클래스에 1개만 선언

 (4) 레퍼런스(Reference)
  - new 메서드명(); 힙객체에 객체 생성
  - 힙영역에 생성된 객체의 '주소'를 레퍼런스라고 부른다.
  - 참조변수 = 레퍼런스 변수 는 그 주소를 저장하여 힙 영역의 객체를 가리킨다.
  - 객체를 가리키는 주소값(또는 그 변수)
	------------------------------------------
	표현            의미	 
	------------------------------------------
	참조 변수        객체의 주소를 저장하는 변수
	레퍼런스 변수      참조 변수와 동일 
	레퍼런스         객체를 가리키는 주소값(또는 그 변수)
	------------------------------------------
	"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"
	String s = "hello";
	s : 참조변수 / 레퍼런스 변수
	"hello" : 객체
	s 안에는 객체 주소(레퍼런스)가 들어 있음
	"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"

5) 메서드(Method)
 - 클래스 안에 정의된 '기능(행동)'
 - 입력(매개변수)를 받아서 처리하고, 결과(리턴)이 있거나 없기도 하다.

6) static 메서드 vs 인스턴스 메서드
 (1) static 메서드
  - 객체(인스턴스)를 만들지 않고, 클래스 이름으로 바로 호출할 수 있는 메서드

 (2) 인스턴스 메서드
  - 객체를 만들어서 '참조변수(레퍼런스 변수)로 메서드 호출'

7) 매개변수(Parameter) vs 전달인자(Argument)
 - 매개변수 : 메서드 '정의할 때' 적는 변수
 - 전달인자 : 메서드 '호출할 때' 넣는 실제 값

8) 생성자(Constructor)
 - 객체를 만들 때 딱 1번만 실행되는 '초기화 전용 메서드'
 - 특징
  - 이름이 '클래스명과 같음'
  - 'new 클래스명();' 에 의해서 호출
  - '리턴타입'이 없음
  - 생성자도 '메서드의 일종'이기 때문에 '오버로딩이 가능'하다.
  - '기본 생성자'는 '매개변수가 없는 생성자'를 말한다.
    생성자가 '오버로딩이 안된 경우'에는 자바 컴파일러는 '묵시적인 기본생성자를 제공'한다.
  - 생성자가 '오버로딩이 되면' 자바 컴파일러는 더 이상 '묵시적인 기본생성자를 제공하지 않는다'.

9) this
 - 좌측 멤버변수와 우측 매개변수명이 같을 때는 멤버변수 앞에 this.을 붙여야 저장된다.
 - this는 내 자신 '인스턴스 가리키는 참조 변수'이다.

10) 상속
 - 자식이 부모가 가지고 있는 재산이나 권력을 물려받는다는 의미이다.
 - '생성자는 상속이 안된다'
 - 특정(자식) 클래스는 다른(부모) 클래스가 가지고 있는 모든 멤버변수나 멤버함수를 사용할 수 있다.

11) 오버로딩 vs 오버라이딩
 (1) 오버로딩
   - 상속과 관련이 없다.
   - 동일한 같은 클래스내에서 같은 이름의 메서드명을 중복해서 여러번 정의하는 것을 말한다.
   ** '개수', '타입', '순서' 를 다르게 선언이 가능하다.

 (2) 오버라이딩
  - 오버라이딩을 하기 위해서 사전에 반드시 '상속'관계를 만들어야 한다.
  - 상속관계에서 부모의 '메서드명', 메서드 '리턴타입', '매개변수 타입과 개수' 모두 동일한 '원형'을 자손에서 
    상속받은 상태에서 '부모클래스로부터 상속받은 메서드 내용을 자식 클래스에 맞게 변경하는 것을 오버라이딩 이라 한다'.
  - 생성자가 오버로딩되면 자바는 기본생성자를 묵시적으로 제공하지 않는다.
  - 생성자가 오버로딩 될 때 '자식클래스에서 기본생성자를 호출하고자 할 때 문제가 발생'한다.
  - 부모클래스에서 생성자가 오버로딩 되면 상속에서의 생성자 호출문제가 발생 명시적인 기본생성자를 정의하는 것이 좋다.
  - 생성자는 상속되지 않는다.
  - 자식클래스에서 new 클래스명();에 의해서 생성자를 호출하면 '자바는 먼저 부모클래스 기본생성자를 먼저 호출'하도록
    설계되어 있다.

 (3) 상속관계에서 자손에서 부모의 메서드를 호출할 때는 super.메서드();를 사용 한다.

12) 업캐스팅 vs 다운캐스팅
 '다형성'이란?
 부모타입 참조변수 = new 자식타입();
 부모타입 참조변수 = new 자식타입();
 부모타입 참조변수 = new 자식타입();
 - '하나의 부모타입 참조 변수로 서로 다른 자식 객체를 참조하여 같은 메서드에 대해 서로 다른 동작을 하게 하는 것'
 - 하나의 이름으로 여러 다른 형태의 동작을 하는 능력

 (1) 업캐스팅
  부모타입 참조변수 = new 자식타입();
  - 업캐스팅을 하려면 사전에 상속 관계를 만들어야 한다.
  - '자식 객체를 부모 타입의 참조 변수로 참조하는 것이다.'
    하나의 부모 타입으로 여러 자식 객체를 동일하게 처리하기 위한 기법이다.
  - 자손타입이 부모타입으로 올라가는 현상을 말한다. '업캐스팅은 암묵적인 자동형변환을 해준다'.
  - 업캐스팅을 통해 '부모 클래스 동일한 메서드 호출에 대해 서로 다른 동작이 필요할 경우에만 오버라이딩을 한다'.

 (2) 다운캐스팅
 자식타입 참조변수 = (자식타입)부모타입변수;
  - 다운캐스팅은 부모 타입을 자손타입으로 내리는 것을 말한다.
  - 다운캐스팅을 하려면 사전에 '상속'관계를 만들어야 한다.
  - 다운캐스팅을 하려면 '사전에 업캐스팅'을 해야 한다.
  - 다운캐스팅을 하려면 자동형변환이 안되기 때문에 '명시적인 형변환' 즉 캐스팅 연산자를 사용해서 강제 다운캐스팅을 해야 한다.
  - '부모 타입에는 없고, 자식 클래스에만 있는 기능을 사용하기 위해서' 다운캐스팅을 한다.

13) instanceof
 - 형변환(레퍼런스간의 업캐스팅과 다운캐스팅) 유무 판단 연산자
 - 다운캐스팅을 할 때 캐스팅 연산 예외 오류가 나는 것을 방지하기 위해서 if 조건문과 함께 사용한다.

14) abstract
 - 추상클래스는 abstract class 키워드로 정의한다.
 - 추상클래스는 new 키워드로 '객체 생성을 할 수 없다.'
 - '추상클래스'에는 '추상메서드가 올 수 있다'. '추상메서드는 {}가 없고', '실행문장이 없다'. '호출이 불가능'하다.
 - '추상클래스를 상속받은 자식클래스에서 부모 추상클래스의 추상메서드를 오버라이딩 해야 한다'.
 - 추상클래스는 멤버변수와 메서드를 가질 수 있다.
 - 객체 생성을 막고 공통기능을 제공, 자식클래스에게 반드시 구현해야 할 규칙을 강제하고,
   '다형성을 통해 유지보수와 확장성을 높이기 위해 사용'한다.

15) final 키워드
 - '변수'를 final로 정의하면 '수정할 수 없는 변수 즉 상수'가 된다.
	· 상수는 선언과 동시에 반드시 '초기화'
	· 상수명은 '영문 대문자'
 - '클래스'를 final로 선언하면 '더 이상 상속을 허락하지 않는다'.
 - '메서드'를 final로 선언하면 '더 이상 오버라이딩을 허락하지 않는다'.

16) interface [인터페이스]
class 자손클래스명 implements 부모인터페이스명

 - interface 예약어로 정의한다.
 - implements 키워드로 자손클래스에서 구현 상속한다.
 - 인터페이스에 오는 추상메서드는 public abstract 키워드로 정의한다. 이 키워드는 '생략가능'하다.
 - 부모 인터페이스를 구현 상속한 자손클래스에서 부모의 모든 추상메서드를 '반드시 오버라이딩 해야 한다는 강제성이 부여'된다.
   그래야만 '자손클래스 객체 생성이 가능'하다.
 - 인터페이스는에 모든 변수는 public static final 로 인식되는 '정적상수'만 올 수 있다.
 - 인터페이스는 하나 이상의 부모 인터페이스로 부터 '다중상속'을 받을 수 있다.
  (1) 자손클래스 -> 인터페이스 + 인터페이스 다중상속
    class 자손클래스명 implements 부모인터페이스명, 부모인터페이스명
  (2) 자손클래스 -> 추상클래스 + 인터페이스 다중상속
	class 자손클래스명 extends 부모추상클래스명 implements 부모인터페이스명
  (3) 자손인터페이스 -> 인터페이스 + 인터페이스 다중상속
    interface 자손인터페이스명 extends 부모인터페이스명, 부모인터페이스명
	
 - 부모 인터페이스의 디폴트 메서드명과 부모 클래스의 일반 메서드명이 동일한 경우
   '부모 클래스의 일반 메서드가 상속'되어 진다.
 

17) default [디폴트 메서드]
 - 부모 인터페이스에 추가된 추상메서드는 반드시 이를 구현 상속한 자손클래스에서 오버라이딩을 해야 한다.
 - '불필요한 추상메서드까지 무조건 오버라이딩을 해야 하는 불편함 존재'
 - 이를 해결하기 위해 추가된 것이 '디폴트 메서드'
 - 디폴트 메서드는 부모 인터페이스에 추가되어도 '자손에서 반드시 오버라이딩을 하지 않아도 된다'.
 - 필요하면 오버라이딩 가능 / '선택적 오버라이딩'
 - 하지만 부모 인터페이스에 추가된 추상메서드는 꼭 자손에서 무조건 오버라이딩을 해야 한다.

18) sealed
불필요한 자손을 함부로 생성하는 것을 방지하기 위해서 봉인 인터페이스가 도입

19) 추상메서드
- 추상클래스 또는 인터페이스 안에 생성가능

20) 컬렉션
 - 컬렉션은 '복수개의 타입을 동시 저장'할 수 있다.
 - 컬렉션은 '복수개의 요소값을 동시 저장'이 가능하다.
 - 컬렉션은 '가변적 배열'이다.
 - 복수개의 타입을 저장할 수 있지만 'generic을 참조해서 1개의 타입만 저장'한다.
 
 (1) 인터페이스
  · Set
   - 중복 데이터 불가
   - 순서 보장 안됨
	1.1 구현 클래스
	 - HashSet : 중복X, 순서X
	 - LinkedHashSet : 중복X, 입력 순서 유지
	 
  · List
   - 저장되는 순서를 보장한다.
   - 중복 원소값을 허용한다.
   - 자바 2버전에서 추가되었고, 실제 자바 프로젝트 개발에서 가장 사용빈도가 높다.
   - 복수개의 원소값을 동시에 저장 가능하고 가변적 크기이다.
   - 배열주소 인덱스 번호처럼 0부터 시작한다. 복수개의 자료형을 동시 저장할 수 있다.
    1.2 구현 클래스
	 - ArrayList
	 - Vector
	  ㄴ Stack
	 
  · Queue
   - 먼저 넣은 데이터가 먼저 나옴
   - First In First Out (FIFO)
    1.3 구현 클래스
	 - LinkedList
	 
 (2) Map 인터페이스
  · Map
   - 키, 객체 쌍으로 저장되는 사전적인 컬렉션 자료구조이다.
   - 키를 통해서 값을 검색하기 때문에 검색 속도가 빠르다.
   - 저장되는 순서를 보장하지 않는다.
   - Hashtable 컬렉션 클래스는 jdk 1.0버전에서 추가되었고, Map 컬렉션 부모인터페이스는 jdk 1.2버전에서 추가되었다.
	1.1 구현 클래스
	 - HashMap : 1.2 추가
	 - Hashtable : 1.0 추가

 (3) 순회 인터페이스
  · Iterator
   - 자바 2버전에서 추가됨
   - 컬렉션에 저장된 복수개의 데이터를 쉽게 읽어오는 용도로 사용된다. 저장되는 용도로 사용하는 컬렉션 자료구조는 아니다.
   - 한번 읽어온 자료는 다시 읽어오지 못한다. 다시 읽어오기 위해서는 재 생성해야 한다.
   - 단방향으로만 데이터를 읽어온다.
   - 주로 자바 2버전에서 추가된 컬렉션과 잘 맞는다.
    1.1 구현 상속 인터페이스
	 - ListIterator
	  · Iterator 인터페이스를 상속해서 기능을 추가한 것으로 컬렉션에 저장된 복수개의 원소값을 읽어 올 때 양방향으로
	    모두 읽어올 수 있다는 장점이 있다.
	  · ArrayList, LinkedList 등 에서만 사용 가능
 
  · Enumeration
   - 자바 1버전에서 추가된 언터페이스로 컬렉션에 저장된 복수개의 원소값을 순방향으로 쉽게 읽어오는 용도로 사용되고
     저장되는 컬렉션 자료구조로는 사용하지 않는다.
   - Iterator의 구버전으로 한 번 사용한 것은 다시 사용 못한다. 다시 사용할려면 재 생성해야 한다.
   - 자바 1버전에서 추가된 컬렉션 클래스와 잘 맞는다.


 (9) 제네릭
  1. <제네릭 타입>은 기본타입으로 지정할 수 없고 참조 레퍼런스 타입으로 지정해야 한다. <제네릭 타입>은
    자바 5버전에서(jdk 1.5)에서 추가되었다.
  2. 제네릭 타입을 지정하면 지정한 자료형으로만 저장 가능하다.
  3. 제네릭 타입을 지정하지 않으면 불필요한 레퍼런스 간의 형변환인 업캐스팅과 다운캐스팅을 해야 한다. 그만큼
     프로그램 실행속도가 떨어지고 코드가 복잡해 져서 가독성이 안 좋아진다. 그리고 원하는 자료 추출도 어려워서
	 자료의 안정성도 떨어진다.