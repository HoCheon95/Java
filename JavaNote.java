[접근 제어자] [기타 제어자] [반환 타입] [메서드명] (매개변수 목록)
1. 접근 제어자
 · 메서드에 접근할 수 있는 범위를 결정
 · 4개 중 하나만 선택
| 접근 지정자 | 같은 클래스| 같은 패키지 | 자식 클래스(다른 패키지)	| 전체		|
| --------- | ------      | ------     | --------------		    | --		|
| public    | ⭕          | ⭕        | ⭕					    | ⭕		|
| protected	| ⭕          | ⭕        | ⭕					    | ❌		|
| default   | ⭕          | ⭕        | ❌				    	| ❌		|
| private   | ⭕          | ❌        | ❌				    	| ❌		|

기호		의미					자바 접근 지정자
+		public				public
#		protected			protected
~		default (package)	접근지정자 없음
-		private				private

2. 기타 제어자
 · static : 객체 없이 호출 가능
 · final : 오버라이딩 불가
 · abstract : 추상 클래스 / 구현 없음
 · synchronized : 동기화
 · native : C/C++ 연동
 · strictfp : 실수 연산 표준화
 · 0개 이상 가능(여러 개 가능)

3. 반환 타입
 · void : return 없음 / void 사용 안할시 return 있음
 · 기본형 (int, double, boolean, char, byte, float, short, long)
 · 참조형 (String, 클래스형, 배열형, 인터페이스 형)

4. 메서드명
 · 메서드를 호출할 떄 사용하는 이름

5. 매개변수 목록
 · 메서드 호출 시 전달받는 값

'ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ'

1) 클래스(Class)
 - 정의 : 객체를 정의해 놓은 것
 - 용도 : 객체를 생성하는데 사용
 - '어떤 데이터를 가지고(필드), 어떤 행동을 할지(메서드)'를 한 덩어리로 정의한 것

2) 객체(Object)
 - 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻함
	Car c1 = new Car(); // 객체 생성
	Car c2 = new Car(); // 또 다른 객체 생성

	new Car() // 힙(heap)에 객체 생성
	Car c1    // Car 타입의 참조변수 선언
	=		   // 생성된 객체의 주소를 저장

3) 인스턴스(Instance)(객체)
 - 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

4) 변수(Variable)
 (1) 지역 변수(Local Variable)
  - '메서드', '생성자', 또는 '블록({})' '안에서 선언'되어 그 '블록 안에서만 사용 가능한 변수'
  - '초기값' 설정 해줘야됨

 (2) 필드(Field) = 멤버 변수(Member Variable)
  - 클래스 안에 선언되는 변수
  - 객체가 가지는 '속성'

 (3) 정적 변수(static 변수, 클래스 변수)
  - static 키워드로 선언
  - 모든 객체가 하나의 값을 공유
  - 클래스에서만 선언 가능
  - 클래스에 1개만 선언

 (4) 레퍼런스(Reference)
  - new 메서드명(); 힙객체에 객체 생성
  - 힙영역에 생성된 객체의 '주소'를 레퍼런스라고 부른다.
  - 참조변수 = 레퍼런스 변수 는 그 주소를 저장하여 힙 영역의 객체를 가리킨다.
  - 객체를 가리키는 주소값(또는 그 변수)
	------------------------------------------
	표현            의미	 
	------------------------------------------
	참조 변수        객체의 주소를 저장하는 변수
	레퍼런스 변수      참조 변수와 동일 
	레퍼런스         객체를 가리키는 주소값(또는 그 변수)
	------------------------------------------
	"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"
	String s = "hello";
	s : 참조변수 / 레퍼런스 변수
	"hello" : 객체
	s 안에는 객체 주소(레퍼런스)가 들어 있음
	"ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ"

5) 메서드(Method)
 - 클래스 안에 정의된 '기능(행동)'
 - 입력(매개변수)를 받아서 처리하고, 결과(리턴)이 있거나 없기도 하다.

6) static 메서드 vs 인스턴스 메서드
 (1) static 메서드
  - 객체(인스턴스)를 만들지 않고, 클래스 이름으로 바로 호출할 수 있는 메서드

 (2) 인스턴스 메서드
  - 객체를 만들어서 '참조변수(레퍼런스 변수)로 메서드 호출'

7) 매개변수(Parameter) vs 전달인자(Argument)
 - 매개변수 : 메서드 '정의할 때' 적는 변수
 - 전달인자 : 메서드 '호출할 때' 넣는 실제 값

8) 생성자(Constructor)
 - 객체를 만들 때 딱 1번만 실행되는 '초기화 전용 메서드'
 - 특징
  - 이름이 '클래스명과 같음'
  - 'new 클래스명();' 에 의해서 호출
  - '리턴타입'이 없음
  - 생성자도 '메서드의 일종'이기 때문에 '오버로딩이 가능'하다.
  - '기본 생성자'는 '매개변수가 없는 생성자'를 말한다.
    생성자가 '오버로딩이 안된 경우'에는 자바 컴파일러는 '묵시적인 기본생성자를 제공'한다.
  - 생성자가 '오버로딩이 되면' 자바 컴파일러는 더 이상 '묵시적인 기본생성자를 제공하지 않는다'.

9) this
 - 좌측 멤버변수와 우측 매개변수명이 같을 때는 멤버변수 앞에 this.을 붙여야 저장된다.
 - this는 내 자신 '인스턴스 가리키는 참조 변수'이다.

10) 상속
 - 자식이 부모가 가지고 있는 재산이나 권력을 물려받는다는 의미이다.
 - '생성자는 상속이 안된다'
 - 특정(자식) 클래스는 다른(부모) 클래스가 가지고 있는 모든 멤버변수나 멤버함수를 사용할 수 있다.

11) 오버로딩 vs 오버라이딩
 (1) 오버로딩
   - 상속과 관련이 없다.
   - 동일한 같은 클래스내에서 같은 이름의 메서드명을 중복해서 여러번 정의하는 것을 말한다.
   ** '개수', '타입', '순서' 를 다르게 선언이 가능하다.

 (2) 오버라이딩
  - 오버라이딩을 하기 위해서 사전에 반드시 '상속'관계를 만들어야 한다.
  - 상속관계에서 부모의 '메서드명', 메서드 '리턴타입', '매개변수 타입과 개수' 모두 동일한 '원형'을 자손에서 
    상속받은 상태에서 '부모클래스로부터 상속받은 메서드 내용을 자식 클래스에 맞게 변경하는 것을 오버라이딩 이라 한다'.
  - 생성자가 오버로딩되면 자바는 기본생성자를 묵시적으로 제공하지 않는다.
  - 생성자가 오버로딩 될 때 '자식클래스에서 기본생성자를 호출하고자 할 때 문제가 발생'한다.
  - 부모클래스에서 생성자가 오버로딩 되면 상속에서의 생성자 호출문제가 발생 명시적인 기본생성자를 정의하는 것이 좋다.
  - 생성자는 상속되지 않는다.
  - 자식클래스에서 new 클래스명();에 의해서 생성자를 호출하면 '자바는 먼저 부모클래스 기본생성자를 먼저 호출'하도록
    설계되어 있다.

 (3) 상속관계에서 자손에서 부모의 메서드를 호출할 때는 super.메서드();를 사용 한다.

12) 업캐스팅 vs 다운캐스팅
 '다형성'이란?
 부모타입 참조변수 = new 자식타입();
 부모타입 참조변수 = new 자식타입();
 부모타입 참조변수 = new 자식타입();
 - '하나의 부모타입 참조 변수로 서로 다른 자식 객체를 참조하여 같은 메서드에 대해 서로 다른 동작을 하게 하는 것'
 - 하나의 이름으로 여러 다른 형태의 동작을 하는 능력

 (1) 업캐스팅
  부모타입 참조변수 = new 자식타입();
  - 업캐스팅을 하려면 사전에 상속 관계를 만들어야 한다.
  - '자식 객체를 부모 타입의 참조 변수로 참조하는 것이다.'
    하나의 부모 타입으로 여러 자식 객체를 동일하게 처리하기 위한 기법이다.
  - 자손타입이 부모타입으로 올라가는 현상을 말한다. '업캐스팅은 암묵적인 자동형변환을 해준다'.
  - 업캐스팅을 통해 '부모 클래스 동일한 메서드 호출에 대해 서로 다른 동작이 필요할 경우에만 오버라이딩을 한다'.

 (2) 다운캐스팅
 자식타입 참조변수 = (자식타입)부모타입변수;
  - 다운캐스팅은 부모 타입을 자손타입으로 내리는 것을 말한다.
  - 다운캐스팅을 하려면 사전에 '상속'관계를 만들어야 한다.
  - 다운캐스팅을 하려면 '사전에 업캐스팅'을 해야 한다.
  - 다운캐스팅을 하려면 자동형변환이 안되기 때문에 '명시적인 형변환' 즉 캐스팅 연산자를 사용해서 강제 다운캐스팅을 해야 한다.
  - '부모 타입에는 없고, 자식 클래스에만 있는 기능을 사용하기 위해서' 다운캐스팅을 한다.

13) instanceof
 - 형변환(레퍼런스간의 업캐스팅과 다운캐스팅) 유무 판단 연산자
 - 다운캐스팅을 할 때 캐스팅 연산 예외 오류가 나는 것을 방지하기 위해서 if 조건문과 함께 사용한다.

14) abstract
 - 추상클래스는 abstract class 키워드로 정의한다.
 - 추상클래스는 new 키워드로 '객체 생성을 할 수 없다.'
 - '추상클래스'에는 '추상메서드가 올 수 있다'. '추상메서드는 {}가 없고', '실행문장이 없다'. '호출이 불가능'하다.
 - '추상클래스를 상속받은 자식클래스에서 부모 추상클래스의 추상메서드를 오버라이딩 해야 한다'.
 - 추상클래스는 멤버변수와 메서드를 가질 수 있다.
 - 객체 생성을 막고 공통기능을 제공, 자식클래스에게 반드시 구현해야 할 규칙을 강제하고,
   '다형성을 통해 유지보수와 확장성을 높이기 위해 사용'한다.

15) final 키워드
 - '변수'를 final로 정의하면 '수정할 수 없는 변수 즉 상수'가 된다.
 - '클래스'를 final로 선언하면 '더 이상 상속을 허락하지 않는다'.
 - '메서드'를 final로 선언하면 '더 이상 오버라이딩을 허락하지 않는다'.

16) 인터페이스
 - interface 예약어로 정의한다.
 - 
